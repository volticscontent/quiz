// üîß UTILIT√ÅRIO DE DIAGN√ìSTICO PARA HOSPEDAGEM COMPARTILHADA
// Este arquivo ajuda a identificar e resolver problemas espec√≠ficos

import HostingerConfig from '@/config/hostinger.js'

export class HostingDiagnostics {
  constructor() {
    this.results = {}
    this.issues = []
    this.fixes = []
  }

  // üéØ EXECUTAR DIAGN√ìSTICO COMPLETO
  async runFullDiagnostic() {
    console.log('üîß Iniciando diagn√≥stico completo...')
    
    // Testes b√°sicos
    this.testEnvironment()
    this.testBrowserAPIs()
    this.testUTMCapture()
    this.testLocalStorage()
    this.testNetworking()
    
    // Testes espec√≠ficos da Hostinger
    if (HostingerConfig.utils.isHostinger()) {
      this.testHostingerSpecific()
    }
    
    // Compilar relat√≥rio
    this.compileReport()
    
    return this.getReport()
  }

  // üåê TESTAR AMBIENTE
  testEnvironment() {
    console.log('üåê Testando ambiente...')
    
    this.results.environment = {
      hostname: window.location.hostname,
      protocol: window.location.protocol,
      userAgent: navigator.userAgent,
      isLocalhost: window.location.hostname.includes('localhost'),
      isHostinger: HostingerConfig.utils.isHostinger(),
      timestamp: new Date().toISOString()
    }

    // Verificar se est√° em HTTPS
    if (window.location.protocol !== 'https:' && !this.results.environment.isLocalhost) {
      this.issues.push({
        type: 'security',
        message: 'Site n√£o est√° usando HTTPS',
        severity: 'warning',
        fix: 'Configurar SSL/TLS no painel da Hostinger'
      })
    }
  }

  // üîß TESTAR APIs DO BROWSER
  testBrowserAPIs() {
    console.log('üîß Testando APIs do browser...')
    
    this.results.browserAPIs = {
      localStorage: this.testAPI(() => {
        localStorage.setItem('test', 'test')
        localStorage.removeItem('test')
        return true
      }),
      
      sessionStorage: this.testAPI(() => {
        sessionStorage.setItem('test', 'test')
        sessionStorage.removeItem('test')
        return true
      }),
      
      urlSearchParams: this.testAPI(() => {
        new URLSearchParams('test=1')
        return true
      }),
      
      fetch: this.testAPI(() => {
        return typeof fetch !== 'undefined'
      }),
      
      console: this.testAPI(() => {
        console.log()
        return true
      }),
      
      json: this.testAPI(() => {
        JSON.parse('{"test": true}')
        JSON.stringify({test: true})
        return true
      })
    }

    // Verificar problemas
    Object.entries(this.results.browserAPIs).forEach(([api, result]) => {
      if (!result.success) {
        this.issues.push({
          type: 'api',
          message: `API ${api} n√£o est√° funcionando`,
          severity: 'error',
          details: result.error,
          fix: `Usar fallback para ${api}`
        })
      }
    })
  }

  // üéØ TESTAR CAPTURA DE UTM
  testUTMCapture() {
    console.log('üéØ Testando captura de UTM...')
    
    // Testar com URL de exemplo
    const testURL = '?utm_source=test&utm_medium=diagnostic&utm_campaign=hostinger_test'
    
    this.results.utmCapture = {
      currentURL: window.location.href,
      hasUTMParams: window.location.search.includes('utm_'),
      
      // Teste com URLSearchParams
      urlSearchParams: this.testAPI(() => {
        const params = new URLSearchParams(testURL)
        return {
          utm_source: params.get('utm_source'),
          utm_medium: params.get('utm_medium'),
          utm_campaign: params.get('utm_campaign')
        }
      }),
      
      // Teste com regex fallback
      regexFallback: this.testAPI(() => {
        const regex = /[?&](utm_[^=]+)=([^&]*)/g
        const utms = {}
        let match
        
        while ((match = regex.exec(testURL)) !== null) {
          utms[match[1]] = decodeURIComponent(match[2])
        }
        
        return utms
      })
    }

    // Verificar se pelo menos um m√©todo funciona
    if (!this.results.utmCapture.urlSearchParams.success && 
        !this.results.utmCapture.regexFallback.success) {
      this.issues.push({
        type: 'utm',
        message: 'Nenhum m√©todo de captura de UTM est√° funcionando',
        severity: 'critical',
        fix: 'Implementar m√©todo alternativo de captura'
      })
    }
  }

  // üíæ TESTAR LOCALSTORAGE
  testLocalStorage() {
    console.log('üíæ Testando localStorage...')
    
    this.results.localStorage = {
      available: this.testAPI(() => 'localStorage' in window),
      
      write: this.testAPI(() => {
        localStorage.setItem('diagnostic_test', 'test_value')
        return true
      }),
      
      read: this.testAPI(() => {
        const value = localStorage.getItem('diagnostic_test')
        return value === 'test_value'
      }),
      
      delete: this.testAPI(() => {
        localStorage.removeItem('diagnostic_test')
        return localStorage.getItem('diagnostic_test') === null
      }),
      
      quota: this.testAPI(() => {
        // Tentar estimar quota do localStorage
        let data = ''
        let i = 0
        
        try {
          for (i = 0; i < 1000; i++) {
            data += '0123456789'
            localStorage.setItem('quota_test', data)
          }
        } catch (e) {
          localStorage.removeItem('quota_test')
          return `Aproximadamente ${i * 10} bytes`
        }
        
        localStorage.removeItem('quota_test')
        return 'Mais de 10KB dispon√≠vel'
      })
    }

    // Verificar problemas com localStorage
    if (!this.results.localStorage.available.success) {
      this.issues.push({
        type: 'storage',
        message: 'localStorage n√£o est√° dispon√≠vel',
        severity: 'error',
        fix: 'Usar fallback com vari√°veis globais'
      })
    }
  }

  // üåê TESTAR CONECTIVIDADE
  testNetworking() {
    console.log('üåê Testando conectividade...')
    
    this.results.networking = {
      online: navigator.onLine,
      
      // Testar se consegue fazer requests
      fetch: this.testAPI(async () => {
        if (typeof fetch === 'undefined') return false
        
        // Tentar fazer request para o pr√≥prio dom√≠nio
        const response = await fetch(window.location.origin, {
          method: 'HEAD',
          mode: 'no-cors'
        })
        
        return true
      }),
      
      // Verificar se scripts externos carregam
      externalScripts: this.testAPI(() => {
        const scripts = document.querySelectorAll('script[src]')
        return scripts.length > 0
      })
    }
  }

  // üè† TESTES ESPEC√çFICOS DA HOSTINGER
  testHostingerSpecific() {
    console.log('üè† Testando espec√≠ficos da Hostinger...')
    
    this.results.hostinger = {
      detected: true,
      
      // Verificar limita√ß√µes conhecidas
      phpSession: this.testAPI(() => {
        // Verificar se h√° cookies de sess√£o PHP
        return document.cookie.includes('PHPSESSID')
      }),
      
      // Verificar se h√° headers espec√≠ficos
      serverHeaders: this.testAPI(() => {
        // Tentar detectar servidor via erro 404
        return fetch('/nonexistent-page-test-404')
          .then(response => response.text())
          .then(text => text.includes('hostinger') || text.includes('000webhost'))
          .catch(() => false)
      }),
      
      // Verificar limita√ß√µes de recursos
      resourceLimits: this.testAPI(() => {
        const start = performance.now()
        
        // Tentar opera√ß√£o intensiva
        for (let i = 0; i < 100000; i++) {
          Math.random()
        }
        
        const duration = performance.now() - start
        return duration < 1000 // Deve completar em menos de 1 segundo
      })
    }

    // Adicionar recomenda√ß√µes espec√≠ficas da Hostinger
    this.fixes.push({
      type: 'hostinger',
      message: 'Configura√ß√µes recomendadas para Hostinger',
      steps: [
        'Ativar compress√£o GZIP no painel',
        'Configurar cache do browser',
        'Otimizar imagens para web',
        'Usar CDN se poss√≠vel',
        'Minimizar uso de localStorage'
      ]
    })
  }

  // üîß TESTAR API INDIVIDUAL
  testAPI(testFunction) {
    try {
      const result = testFunction()
      
      // Se retornar uma Promise, aguardar
      if (result instanceof Promise) {
        return result
          .then(res => ({ success: true, result: res }))
          .catch(error => ({ success: false, error: error.message }))
      }
      
      return { success: true, result }
    } catch (error) {
      return { success: false, error: error.message }
    }
  }

  // üìä COMPILAR RELAT√ìRIO
  compileReport() {
    console.log('üìä Compilando relat√≥rio...')
    
    // Contar problemas por severidade
    const issueCounts = {
      critical: this.issues.filter(i => i.severity === 'critical').length,
      error: this.issues.filter(i => i.severity === 'error').length,
      warning: this.issues.filter(i => i.severity === 'warning').length
    }

    // Determinar status geral
    let overallStatus = 'healthy'
    if (issueCounts.critical > 0) {
      overallStatus = 'critical'
    } else if (issueCounts.error > 0) {
      overallStatus = 'problematic'
    } else if (issueCounts.warning > 0) {
      overallStatus = 'needs_attention'
    }

    this.results.summary = {
      overallStatus,
      issueCounts,
      totalIssues: this.issues.length,
      totalFixes: this.fixes.length,
      timestamp: new Date().toISOString()
    }
  }

  // üìã OBTER RELAT√ìRIO COMPLETO
  getReport() {
    return {
      summary: this.results.summary,
      environment: this.results.environment,
      browserAPIs: this.results.browserAPIs,
      utmCapture: this.results.utmCapture,
      localStorage: this.results.localStorage,
      networking: this.results.networking,
      hostinger: this.results.hostinger,
      issues: this.issues,
      fixes: this.fixes,
      generatedAt: new Date().toISOString()
    }
  }

  // üñ®Ô∏è IMPRIMIR RELAT√ìRIO NO CONSOLE
  printReport() {
    const report = this.getReport()
    
    console.group('üîß RELAT√ìRIO DE DIAGN√ìSTICO')
    
    console.log('üìä Status Geral:', report.summary.overallStatus)
    console.log('üåê Ambiente:', report.environment)
    console.log('üîß APIs do Browser:', report.browserAPIs)
    console.log('üéØ Captura UTM:', report.utmCapture)
    console.log('üíæ LocalStorage:', report.localStorage)
    console.log('üåê Rede:', report.networking)
    
    if (report.hostinger) {
      console.log('üè† Hostinger:', report.hostinger)
    }
    
    if (report.issues.length > 0) {
      console.group('‚ö†Ô∏è PROBLEMAS ENCONTRADOS')
      report.issues.forEach(issue => {
        console.warn(`[${issue.severity.toUpperCase()}] ${issue.message}`)
        if (issue.fix) {
          console.log(`   üí° Solu√ß√£o: ${issue.fix}`)
        }
      })
      console.groupEnd()
    }
    
    if (report.fixes.length > 0) {
      console.group('üîß CORRE√á√ïES RECOMENDADAS')
      report.fixes.forEach(fix => {
        console.log(`${fix.message}:`)
        if (fix.steps) {
          fix.steps.forEach(step => console.log(`  ‚Ä¢ ${step}`))
        }
      })
      console.groupEnd()
    }
    
    console.groupEnd()
    
    return report
  }
}

// üéØ FUN√á√ÉO UTILIT√ÅRIA PARA EXECUTAR DIAGN√ìSTICO R√ÅPIDO
export const runQuickDiagnostic = async () => {
  const diagnostics = new HostingDiagnostics()
  const report = await diagnostics.runFullDiagnostic()
  diagnostics.printReport()
  
  // Adicionar ao window para acesso global
  window._diagnosticReport = report
  
  return report
}

// üéØ FUN√á√ÉO PARA TESTAR APENAS UTMs
export const testUTMOnly = () => {
  console.log('üéØ Teste r√°pido de UTM...')
  
  const currentURL = window.location.href
  const hasUTMs = currentURL.includes('utm_')
  
  console.log('URL atual:', currentURL)
  console.log('Tem UTMs:', hasUTMs)
  
  if (hasUTMs) {
    // Testar captura
    try {
      const params = new URLSearchParams(window.location.search)
      const utms = {
        utm_source: params.get('utm_source'),
        utm_medium: params.get('utm_medium'),
        utm_campaign: params.get('utm_campaign'),
        utm_content: params.get('utm_content'),
        utm_term: params.get('utm_term')
      }
      
      console.log('UTMs capturados:', utms)
      return utms
    } catch (error) {
      console.error('Erro ao capturar UTMs:', error)
      return null
    }
  }
  
  return null
}

export default HostingDiagnostics 